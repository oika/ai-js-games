<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Infinite Puzzle Game</title>
  <style>
    body {
      text-align: center;
      background-color: #f0f0f0;
      font-family: sans-serif;
      margin: 0;
      padding: 20px;
    }
    /* キャンバスを含むコンテナ（オーバーレイの基準にする） */
    #gameContainer {
      position: relative;
      display: inline-block;
    }
    canvas {
      border: 1px solid #000;
      background-color: #fff;
      display: block;
    }
    /* ゲームオーバー時に表示するオーバーレイ */
    #gameOverOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 400px;
      height: 400px;
      background-color: rgba(0, 0, 0, 0.5);
      display: none; /* 初期状態は非表示 */
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    #overlayContent {
      background: white;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
    }
    #overlayContent p {
      font-size: 20px;
      margin: 0 0 10px;
    }
    #retryButton {
      font-size: 16px;
      padding: 8px 16px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <!-- キャンバスとオーバーレイを包含するコンテナ -->
  <div id="gameContainer">
    <canvas id="gameCanvas" width="400" height="400"></canvas>
    <div id="gameOverOverlay">
      <div id="overlayContent">
        <p id="finalScore">Final Score: 0</p>
        <button id="retryButton">Retry</button>
      </div>
    </div>
  </div>
  <!-- 現在のスコア表示（ゲーム中は更新されます） -->
  <p>Score: <span id="score">0</span></p>

  <script>
    // キャンバスと基本設定
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('score');
    const overlay = document.getElementById('gameOverOverlay');
    const finalScoreDisplay = document.getElementById('finalScore');
    const retryButton = document.getElementById('retryButton');

    const ROWS = 10;
    const COLS = 10;
    const TILE_SIZE = 40;
    const COLORS = ['red', 'green', 'blue', 'orange', 'purple'];

    let grid = [];         // 各セルには色（文字列）または null を保持
    let score = 0;
    let isAnimating = false;  // エフェクト中（爆発、落下、シェイク）は操作を無効化

    // パーティクル用配列（爆発エフェクト用）
    let particles = [];

    // 落下アニメーション用配列
    let movingAnimations = [];
    let animationStartTime = 0;  // 落下アニメーション開始時刻

    // ------------------------------
    // Particle クラス（爆発エフェクト用）
    class Particle {
      constructor(x, y, color) {
        this.x = x;
        this.y = y;
        // 速度は -2～2 のランダム値
        this.vx = (Math.random() - 0.5) * 4;
        this.vy = (Math.random() - 0.5) * 4;
        this.life = 30 + Math.random() * 10;  // 生存フレーム数
        this.color = color;
        this.size = 4 + Math.random() * 3;
      }
      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
      }
      draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // ------------------------------
    // ブロック（セル）の描画
    // ブロックは上部が明るく下部が元色になるリニアグラデーションで描画
    function drawBlock(x, y, color) {
      let gradient = ctx.createLinearGradient(x, y, x, y + TILE_SIZE);
      gradient.addColorStop(0, "white");
      gradient.addColorStop(1, color);
      ctx.fillStyle = gradient;
      ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
      ctx.strokeStyle = "black";
      ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);
    }

    // ------------------------------
    // グリッドの初期化：各セルにランダムな色を配置
    function initGrid() {
      grid = [];
      for (let r = 0; r < ROWS; r++) {
        let row = [];
        for (let c = 0; c < COLS; c++) {
          row.push(randomColor());
        }
        grid.push(row);
      }
    }

    function randomColor() {
      return COLORS[Math.floor(Math.random() * COLORS.length)];
    }

    // ------------------------------
    // グリッド全体の描画（通常状態）
    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (grid[r][c]) {
            drawBlock(c * TILE_SIZE, r * TILE_SIZE, grid[r][c]);
          }
        }
      }
    }

    // ------------------------------
    // パーティクルの描画
    function drawParticles() {
      for (const p of particles) {
        p.draw(ctx);
      }
    }

    // メイン描画関数（エフェクト中はパーティクルも描画）
    function render() {
      drawGrid();
      if (particles.length > 0) {
        drawParticles();
      }
    }

    // ------------------------------
    // クリック座標からグリッド上のセル位置を取得
    function getTileAt(x, y) {
      const col = Math.floor(x / TILE_SIZE);
      const row = Math.floor(y / TILE_SIZE);
      if (row >= 0 && row < ROWS && col >= 0 && col < COLS) {
        return { row, col };
      }
      return null;
    }

    // ------------------------------
    // フラッドフィル：クリックしたセルと同じ色の隣接セル群を再帰的に探索
    function floodFill(row, col, color, visited) {
      if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return [];
      if (visited[row][col]) return [];
      if (grid[row][col] !== color) return [];
      visited[row][col] = true;
      let cells = [[row, col]];
      cells = cells.concat(floodFill(row - 1, col, color, visited));
      cells = cells.concat(floodFill(row + 1, col, color, visited));
      cells = cells.concat(floodFill(row, col - 1, color, visited));
      cells = cells.concat(floodFill(row, col + 1, color, visited));
      return cells;
    }

    // ------------------------------
    // 対象セル群を grid から削除（null に設定）
    function removeCells(cells) {
      for (const cell of cells) {
        const [r, c] = cell;
        grid[r][c] = null;
      }
    }

    // ------------------------------
    // 重力処理：各列内でセルを下に詰める
    function applyGravity() {
      for (let c = 0; c < COLS; c++) {
        let colCells = [];
        for (let r = 0; r < ROWS; r++) {
          if (grid[r][c] !== null) {
            colCells.push(grid[r][c]);
          }
        }
        for (let r = ROWS - 1; r >= 0; r--) {
          if (colCells.length > 0) {
            grid[r][c] = colCells.pop();
          } else {
            grid[r][c] = null;
          }
        }
      }
    }

    // ------------------------------
    // 列シフト：空の列を除去して左に詰める
    function shiftColumns() {
      let nonEmptyCols = [];
      for (let c = 0; c < COLS; c++) {
        let isEmpty = true;
        for (let r = 0; r < ROWS; r++) {
          if (grid[r][c] !== null) {
            isEmpty = false;
            break;
          }
        }
        if (!isEmpty) nonEmptyCols.push(c);
      }
      let newGrid = Array.from({ length: ROWS }, () => new Array(COLS).fill(null));
      let newCol = 0;
      for (let c of nonEmptyCols) {
        for (let r = 0; r < ROWS; r++) {
          newGrid[r][newCol] = grid[r][c];
        }
        newCol++;
      }
      grid = newGrid;
    }

    // ------------------------------
    // 爆発エフェクトの開始
    function startExplosion(cells, color, callback) {
      // 各セル位置からパーティクルを発生
      for (const cell of cells) {
        const [r, c] = cell;
        const centerX = c * TILE_SIZE + TILE_SIZE / 2;
        const centerY = r * TILE_SIZE + TILE_SIZE / 2;
        const numParticles = 5 + Math.floor(Math.random() * 4);
        for (let i = 0; i < numParticles; i++) {
          particles.push(new Particle(centerX, centerY, color));
        }
      }
      const explosionDuration = 600; // ミリ秒
      let startTime = null;
      function animateExplosion(timestamp) {
        if (!startTime) startTime = timestamp;
        let elapsed = timestamp - startTime;
        particles.forEach(p => p.update());
        particles = particles.filter(p => p.life > 0);
        render();
        if (elapsed < explosionDuration || particles.length > 0) {
          requestAnimationFrame(animateExplosion);
        } else {
          callback();
        }
      }
      requestAnimationFrame(animateExplosion);
    }

    // ------------------------------
    // 落下（移動）エフェクトのアニメーション
    function animateFalling(timestamp) {
      let progress = (timestamp - animationStartTime) / 300; // 300ms で移動完了
      if (progress > 1) progress = 1;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // 各ブロックの移動位置を補間して描画
      for (let anim of movingAnimations) {
        let t = Math.min(1, (timestamp - animationStartTime) / anim.duration);
        let x = anim.startX + (anim.endX - anim.startX) * t;
        let y = anim.startY + (anim.endY - anim.startY) * t;
        drawBlock(x, y, anim.color);
      }
      if (progress < 1) {
        requestAnimationFrame(animateFalling);
      } else {
        movingAnimations = [];
        isAnimating = false;
        render();
        checkGameOver();
      }
    }

    // ------------------------------
    // シェイクエフェクト：消えないブロックを軽く左右に振る
    function shakeBlock(row, col, color) {
      isAnimating = true;
      const duration = 300; // 300ms
      let startTime = null;
      function animateShake(timestamp) {
        if (!startTime) startTime = timestamp;
        let t = (timestamp - startTime) / duration;
        if (t > 1) t = 1;
        // 振れ幅は最大3px、減衰しながらサイン波で左右に振動
        const amplitude = 3;
        let offset = amplitude * Math.sin(t * Math.PI * 10) * (1 - t);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // 全セルを通常描画。ただし対象セルは x 座標に offset を加える
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            if (grid[r][c]) {
              if (r === row && c === col) {
                drawBlock(c * TILE_SIZE + offset, r * TILE_SIZE, color);
              } else {
                drawBlock(c * TILE_SIZE, r * TILE_SIZE, grid[r][c]);
              }
            }
          }
        }
        if (t < 1) {
          requestAnimationFrame(animateShake);
        } else {
          isAnimating = false;
          render();
          checkGameOver();
        }
      }
      requestAnimationFrame(animateShake);
    }

    // ------------------------------
    // ゲームオーバーかどうかをチェックし、オーバーレイを表示する
    function checkGameOver() {
      if (!hasMoves()) {
        showGameOverOverlay();
      }
    }

    // ------------------------------
    // 消せるブロックが残っていない場合のオーバーレイ表示
    function showGameOverOverlay() {
      finalScoreDisplay.textContent = "Final Score: " + score;
      overlay.style.display = "flex";
    }
    function hideGameOverOverlay() {
      overlay.style.display = "none";
    }

    // ------------------------------
    // クリックイベントの処理
    canvas.addEventListener('click', function(event) {
      if (isAnimating) return; // エフェクト中は操作無効
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const tile = getTileAt(x, y);
      if (tile) {
        const { row, col } = tile;
        if (grid[row][col] === null) return;
        let visited = Array.from({ length: ROWS }, () => new Array(COLS).fill(false));
        const cells = floodFill(row, col, grid[row][col], visited);
        // 2 つ以上連結している場合は削除（エフェクト実行）
        if (cells.length >= 2) {
          isAnimating = true;
          startExplosion(cells, grid[row][col], () => {
            // --- 落下アニメーションのために、削除前の各列のブロック位置を記録 ---
            let oldPositionsByCol = [];
            for (let c = 0; c < COLS; c++) {
              let colArray = [];
              for (let r = 0; r < ROWS; r++) {
                if (grid[r][c] !== null) {
                  colArray.push({ row: r, color: grid[r][c], x: c * TILE_SIZE, y: r * TILE_SIZE });
                }
              }
              oldPositionsByCol.push(colArray);
            }
            // ブロック群削除
            removeCells(cells);
            score += cells.length;
            scoreDisplay.textContent = score;
            // 重力処理
            applyGravity();
            // 列シフトの前に、各列の状態を記録
            let nonEmptyCols = [];
            for (let c = 0; c < COLS; c++) {
              let isEmpty = true;
              for (let r = 0; r < ROWS; r++) {
                if (grid[r][c] !== null) { isEmpty = false; break; }
              }
              if (!isEmpty) nonEmptyCols.push(c);
            }
            shiftColumns();
            // --- 落下アニメーション用のデータ作成 ---
            movingAnimations = [];
            for (let j = 0; j < nonEmptyCols.length; j++) {
              let oldCol = nonEmptyCols[j];
              let colBlocks = oldPositionsByCol[oldCol];  // その列にあったブロック（上から順）
              let count = colBlocks.length;
              // 最終的な grid では、該当列 j の下側 count 行が埋まっています
              for (let r = ROWS - count; r < ROWS; r++) {
                if (grid[r][j] !== null) {
                  let index = r - (ROWS - count);
                  let oldBlock = colBlocks[index];
                  movingAnimations.push({
                    color: grid[r][j],
                    startX: oldBlock.x,
                    startY: oldBlock.y,
                    endX: j * TILE_SIZE,
                    endY: r * TILE_SIZE,
                    duration: 300
                  });
                }
              }
            }
            // 落下アニメーション開始
            animationStartTime = performance.now();
            requestAnimationFrame(animateFalling);
          });
        } else {
          // 連結数が 1 なら削除されず、シェイクエフェクトを実行
          shakeBlock(row, col, grid[row][col]);
        }
      }
    });

    // ------------------------------
    // まだ消せる同色の隣接ブロックがあるかチェック
    function hasMoves() {
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (grid[r][c] !== null) {
            let color = grid[r][c];
            if (c + 1 < COLS && grid[r][c + 1] === color) return true;
            if (r + 1 < ROWS && grid[r + 1][c] === color) return true;
          }
        }
      }
      return false;
    }

    // ------------------------------
    // リセット処理（リトライボタン用）
    function resetGame() {
      score = 0;
      scoreDisplay.textContent = score;
      initGrid();
      particles = [];
      movingAnimations = [];
      isAnimating = false;
      hideGameOverOverlay();
      render();
    }

    // リトライボタンのイベントリスナー
    retryButton.addEventListener('click', resetGame);

    // ------------------------------
    // 初期化
    resetGame();
  </script>
</body>
</html>
